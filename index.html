<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8">

        <title>staticconf</title>

        <meta name="author" content="Daniel Nephin">
        <link rel="stylesheet" href="reveal.js/css/reveal.min.css">
        <link rel="stylesheet" href="reveal.js/css/theme/default.css" id="theme">
        <link href='http://fonts.googleapis.com/css?family=PT+Sans'
              rel='stylesheet' type='text/css'>
        <link href='http://fonts.googleapis.com/css?family=Monda'
              rel='stylesheet' type='text/css'>

        <!-- For syntax highlighting -->
        <link rel="stylesheet" href="css/highlight-themes/tomorrow.css">

        <!-- If the query includes 'print-pdf', use the PDF print sheet -->
        <script>
            var css = window.location.search.match( /print-pdf/gi ) ? 'pdf' : 'paper';
            document.write( '<link rel="stylesheet" href="reveal.js/css/print/' + css + 
                            '.css" type="text/css" media="print">' );
        </script>

        <!--[if lt IE 9]>
        <script src="reveal.js/lib/js/html5shiv.js"></script>
        <![endif]-->

        <script src="reveal.js/lib/js/head.min.js"></script>
    <style>

.reveal {
  font-family: 'PT Sans', sans-serif;
}

.reveal h1, .reveal h2, .reveal h3, .reveal h4 {
  text-transform: none;
  font-family: 'Monda', sans-serif;
  letter-spacing: normal;
}

.reveal h2 {
  font-size: 30px;
}

.reveal pre {
  width: 100%;
  margin: 0;
  font-size: 0.7em;
}

.reveal pre code {
  margin: 0 auto;
  max-height: none;
}

.reveal ul.none {
  list-style-type: none;
}

.reveal h3.question,
.reveal h3.title {
  text-shadow: 0 1px 0 #cccccc,
    0 2px 0 #c9c9c9,
    0 3px 0 #bbbbbb,
    0 4px 0 #b9b9b9,
    0 5px 0 #aaaaaa,
    0 6px 1px rgba(0, 0, 0, 0.1),
    0 0 5px rgba(0, 0, 0, 0.1),
    0 1px 3px rgba(0, 0, 0, 0.3),
    0 3px 5px rgba(0, 0, 0, 0.2),
    0 5px 10px rgba(0, 0, 0, 0.25),
    0 20px 20px rgba(0, 0, 0, 0.15);
  font-size: 3em;
}

.reveal p.filename {
  color: #777;
  text-align: left;
  margin-left: 0.5em;
}

.left {
  text-align: left;
  width: 100%;
}

.reveal .padded {
  margin: 1em 0 0.5em 0;
}

.reveal ul.spaced li {
  margin: 0.5em 0 0 0;
}

.reveal pre.smaller {
  font-size: 0.6em;
}

/* TODO: upstream */
.reveal .slides>section,
.reveal .slides > section > section {
  padding: 0;
}

    </style>
    </head>

    <body>

        <div class="reveal">
            <div class="slides">

<section>
    <h1>staticconf</h1>
    <h2>An open source python library for configuration</h2>
</section>

<section>
  <section>
    <h3 class="question">Why?</h3>
  </section>

  <section>
    <p class="filename">config.py</a>
    <pre><code class="python">
  mysql_host = "10.10.10.1"
  mysql_port = 3306

  max_retry = 3
  default_date_fmt = "%Y-%m-%d"
    </code></pre>
  </section>

  <section>
    <p class="filename">config.xml</a>
    <pre><code class="xml">
  <config>
    <mysql>
      <param name="host" type="string">10.10.10.1&lt;/param>
      <param name="port" type="int">330&lt;/param>
    </mysql>
    <webservice>
      <param name="max_retry" type="int">3&lt;/param>
    </webservice>
    <locale>
      <param name="default_date_fmt" type="string">
          %Y-%m-%d&lt;/param>
    </locale>
  </config>
   </code></pre>

  </section>
  <section>
    <p class="filename">config.yaml</a>
    <pre><code class="yaml">
  mysql:
    host: "10.10.10.1"
    port: 3306
  web_services:
    max_retry: 3
  locale:
    default_date_fmt: "%Y-%m-%d"
   </code></pre>
  </section>

</section>

<section>
  <section>
  <h3>Requirements</h3>
  <ul class="spaced left">
    <li>support loading config from different file formats</li>
    <li>tools for working with configuration
      <ul>
        <li>support structured configuration without heavily nested dicts</li>
        <li>configuration validation</li>
        <li>periodically reload configuration</li>
      </ul> 
    </li>
    <li>easily extensible</li>
  </ul>
  </section>

  <section>
    <h3>Options?</h3>
    <ul>
      <li><a href="http://docs.python.org/library/configparser.html">ConfigParser</a> in stdlib</li>
      <li><a href="https://pypi.python.org/pypi/ZConfig">ZConfig</a> from zope</li>
      <li><a href="http://pythonhosted.org/ConfigObject/">ConfigObject</a></li>
    </ul>

  </section>
</section>

<section>
  <section>
    <h3>Getting started - Loading</h3>

    <p class="left padded">Support many configuration file formats</p>
    <ul class="left spaced">
        <li>separate configuration loading from configuration reading</li>
        <li>lots of common code shared between the different loaders</li>
        <li>trade-off: flatten nested structures vs preserve nesting</li>
    </ul>
  </section>

  <section>
  <p class="left">The trade-off: flatten everything</p>
  <p class="filename">flat</p>
  <pre><code class="python">
  {
      'table.max_rows': 10,
      'table.strategy.name': 'alternate',
      'table.strategy.rate': 3
  }
  </code></pre>
  <p class="filename">nested</p>
  <pre><code class="python">
  {
      'table': {
          'max_rows': 10,
          'strategy': {
              'name': 'alternate',
              'rate': 3
           }
      }
  }
  </code></pre>
  </section>

  <section>
    <h3>Configuration object</h3>
    <pre><code class="python">
 class ConfigNamespace(object):
    def __init__(self, name):
        self.configuration_values = {}

    def apply_config_data(self,
            config_data, error_on_unknown, error_on_dupe):
        self.validate_keys(config_data, error_on_unknown)
        self.has_duplicate_keys(config_data, error_on_dupe)
        self.update_values(config_data)

    def get(self, item, default=None):
        ...
    def __getitem__(self, item):
        ...
    def __setitem__(self, key, value):
        ...
    def __contains__(self, item):
        ...
    </code></pre>
  </section>

  <section>
  <p class="left">Build a configuration loading function</p>
  <pre><code class="python">
  def build_loader(loader_func):

      def loader(*args, **kwargs):
          ...
          # Call the loader_func that was passed in
          config_data = load_config_data(
                          loader_func, *args, **kwargs)

          # Flatten the nested structure
          config_data = dict(flatten_dict(config_data))

          # Load it into a ConfigNamespace object
          namespace   = config.get_namespace(name)
          namespace.apply_config_data(config_data, ...)
  
      return loader
  </code></pre>
  </section>

  <section>
  <p class="left">Sample configuration loader functions</p>
  <pre><code class="python">
  def json_loader(filename):
      with open(filename) as fh:
          return json.load(fh)
   
  def python_loader(module_name):
      module = __import__(module_name, fromlist=['*'])
      return object_loader(module)
  
  def ini_file_loader(filename):
      parser = ConfigParser.SafeConfigParser()
      parser.read([filename])
      config_dict = {}
  
      for section in parser.sections():
          for key, value in parser.items(section, True):
              config_dict['%s.%s' % (section, key)] = value
  
      return config_dict
  </code></pre>
  </section>

  <section>
  <p class="left">Build some default loaders for different file formats</p>
  <pre><code class="python">
  YamlConfiguration       = build_loader(yaml_loader)
  JSONConfiguration       = build_loader(json_loader)
  ListConfiguration       = build_loader(list_loader)
  DictConfiguration       = build_loader(lambda d: d)
  ObjectConfiguration     = build_loader(object_loader)
  PythonConfiguration     = build_loader(python_loader)
  INIConfiguration        = build_loader(ini_file_loader)
  XMLConfiguration        = build_loader(xml_loader)
  PropertiesConfiguration = build_loader(properties_loader)
  </code></pre>
  </section>

  <section>
  <p class="left">Build your own</p>
  <pre><code class="python">
  import requests
  from staticconf.loader import build_loader

  def remote_config_loader(url, auth=None):
     return requests.get(url, auth=auth).json()

  RemoteConfiguration = build_loader(remote_config_loader)
  ...

  RemoteConfiguration('http://example.com/config/current')
  </code></pre>
  </section>

  <section>
  <p class="left">Heterogeneous sources</p>
  <pre><code class="python">
  # Load system defaults
  INIConfiguration('/etc/coolapp/config.ini')

  # Load user defaults
  YamlCofiguration('/home/user/.coolapp.yaml')

  # Load overrides from os.environ
  env_config = dict((k, v) for k, v os.environ.iteritems()
                    if  k.startswith('coolapp'))
  DictConfiguration(env_config)

  # Load overrides from optparse
  # parser.add_option('--conf-value', action='append')
  ListConfiguration(opt.conf_value)
  </code></pre>
  </section>

</section>

<section>
  <section>
    <h3>Next - Getting Values</h3>
    <p class="left">Retrieve a value from a ConfigNamespace</p>
    <ul class="left spaced">
      <li>validate type of the value</li>
      <li>cache expensive casting operations</li>
    </ul>
  </section>

  <section>
    <p class="left">Magical proxies</p>
    <pre><code class="python">
  value = staticconf.get_int('something', default=3)

  print range(value)
  # [0, 1, 2]

  print "abcdefg"[:value]
  # "abc"

  print 2 &lt; value &lt; 4
  # True

  print value == 3
  # True

  print type(value)
  # staticconf.proxy.ValueProxy
    </code></pre>
  </section>

  <section>
    <p class="left">What is a ValueProxy?</p>
    <pre><code class="python">
  class ValueProxy(object):
      __slots__ = [ ..., '__weakref__']
   
      def __new__(cls, *args, **kwargs):
          klass = build_class_def(cls)
          instance = object.__new__(klass)
          klass.__init__(instance, *args, **kwargs)
          return instance
  
      def __init__(self,
              validator, namespace, key, default=UndefToken):
          ...
  
      @property
      @cache_as_field('_value')
      def value(self):
          return extract_value(self)
    </code></pre>
  </section>

  <section>
    <p class="left">Fake being every class</p>
    <pre><code class="python">
  def build_class_def(cls):
      ...
  
      contents = dict((name, build_method(name))
                      for name in _special_names)
      return type(cls.__name__, (cls,), contents)


  # method() extracted from above for clarity
  def method(self, *args, **kwargs):
      if name in unary_funcs:
          return unary_funcs[name](self.value)

      if hasattr(operator, name):
          return getattr(operator, name)(self.value, *args)
  
      return getattr(self.value, name)(*args, **kwargs)
    </code></pre>
  </section>

  <section>
    <p class="left">The special methods</p>
    <pre><code class="python">
'__abs__',      '__add__',      '__and__',      '__call__',
'__contains__', '__delitem__',  '__delslice__', '__div__',
'__eq__',       '__float__',    '__floordiv__', '__ge__',
'__getitem__',  '__gt__',       '__hash__',     '__hex__',
'__imul__',     '__int__',      '__invert__',   '__ior__',
'__long__',     '__lshift__',   '__lt__',       '__mod__',
'__mul__',      '__ne__',       '__neg__',      '__oct__',
'__or__',       '__pos__',      '__pow__',      '__radd__',
'__rand__',     '__rdiv__',     '__rdivmod__',  '__reduce__',
'__repr__',     '__reversed__', '__rlshift__',  '__setitem__',
'__setslice__', '__sub__',      '__truediv__',  '__xor__',
'next',         '__nonzero__',  '__str__',      '__index__',
'__irshift__',  '__rsub__',     '__unicode__',  '__iand__',
'__len__',      '__divmod__',   '__rmod__',     ...
    </code></pre>
  </section>
</section>

<section>
  <section>
    <h3>Validators</h3>
    <ul class="spaced">
      <li>configuration formats don't support all types (ex: dates)</li>
      <li>casting things to the type you want can be tedious</li>
    </ul>
  </section>

  <section>
    <p class="left">Common validators</p>
    <pre><code class="python">
  def validate_numeric(type_func, value):
      try:
          return type_func(value)
      except ValueError:
          raise ValidationError(...)

  def validate_int(value):
      return validate_numeric(int, value)

  # Some supported date formats
  date_formats = ["%Y-%m-%d %H:%M:%S", ... ]
  
  def validate_datetime(value):
      for format in date_formats:
          try:
              return datetime.datetime.strptime(value, format)
          except ValueError:
              pass
      raise ValidationError("Invalid date format: %s" % value)
  
    </code></pre>
  </section>

  <section>
    <p class="left">More interesting validators</p>
    <pre><code class="python">
  def validate_set(value):
      return _validate_iterable(set, value)
  
  def validate_regex(value):
      try:
          return re.compile(value)
      except (re.error, TypeError) as e:
          raise ValidationError(...)
  
  def validate_log_level(value):
      try:
          return getattr(logging, value)
      except AttributeError:
          raise ValidationError(...)
    </code></pre>
  </section>

  <section>
    <p class="left">Validator composition</p>
    <pre><code class="python">
  def build_list_type_validator(item_validator):

      def validate_list_of_type(value):
          return [item_validator(item)
                  for item in validate_list(value)]

      return validate_list_of_type


  # Compose a previous validator
  validate_list_of_ints = \
      build_list_type_validator(validate_int)
    </code></pre>
  </section>

  <section>
    <p class="left">Enumerate some common validators</p>
    <pre><code class="python">
   validators = {
      '':          validate_any,
      'bool':      validate_bool,
      'date':      validate_date,
      'datetime':  validate_datetime,
      'float':     validate_float,
      'int':       validate_int,
      'list':      validate_list,
      'set':       validate_set,
      'string':    validate_string,
      'time':      validate_time,
      'tuple':     validate_tuple,
      'regex':     validate_regex,
      'log_level': validate_log_level,
   }
    </code></pre>
  </section>

  <section>
    <p class="left">Build your own</p>
    <pre><code class="python">
  HostConfig = namedtuple('HostConfig', 'host port timeout')

  def validate_something(input):
      try:
          host, port, timeout = validate_tuple(input)
          return HostConfig(validate_string(host),
                            validate_int(port),
                            validate_timeout(timeout))
      except ValueError as e:
          raise ValidationError(
              "Not a valid host config: {0}, {1}"...)
    </code></pre>
    </section>

</section>

<section>
  <section>
    <h3>Back to reading values</h3>
    <p class="left padded">Readers: a more obvious approach</p>
    <ul class="left spaced">
      <li>use validators to get the correct type</li>
      <li>no proxy, no caching</li>
    </ul>
  </section>

  <section>
    <p class="left">Reading from the default ConfigNamespace</p>
    <pre><code class="python">
  import staticconf

  max_iterations = staticconf.read_int('max_iterations',
                                       default=10)

  print "Running until {0}".format(
      staticconf.read_datetime('end_time'))


  logging.getLogger().setLevel(
      staticconf.read_log_level('default_log_level'))
    </code></pre>
  </section>

  <section>
    <p class="left">Reading from a named ConfigNamespace</p>
    <pre><code class="python">
  import staticconf

  connect_timeout = staticconf.read_int(hostname,
                                        namespace='timesouts')

  ...

  timeout_config = staticconf.NamespaceReader('timeouts')

  connect_timeout = timeout_config.read_int(hostname)
    </code></pre>
  </section>

  <section>
    <p class="left">Building from validators, without the boilerplate</p>
    <pre><code class="python">
  def build_reader(validator, ...):
      def reader(config_key,
                 default=UndefToken,
                 namespace=None):

          config_namespace = config.get_namespace(namespace)
          return validator(_read_config(config_key,
                                        config_namespace,
                                        default))
      return reader

  # Put it all together
  def build_accessor_type(name_factory, builder):
      accessor_map = dict(get_all_accessors(name_factory))
      return lambda name: \
          NamespaceAccessor(name, accessor_map, builder)
    </code></pre>
  </section>
</section>

<section>
  <section>
    <h3>Schemas</h3>
    <p>Grouping similar things together is nice</p>
  </section>

  <section>
    <p class="left">Example configuration schema</p>
    <pre><code class="python">
  class MyConfigSchema(object):
      __metaclass__ = schema.SchemaMeta

      namespace = 'my_package'

      # (optional) config path to prepend to keys
      config_path = 'my_class.foo'


      # configured at my_class.foo.ratio
      ratio = schema.float(default=0.2)

      # configured at my_class.foo.max
      max_threshold = schema.int(config_key='max')


  config = MyConfigSchema()
  print config.ratio
    </code></pre>
  </section>

  <section>
    <p class="left">Build your own...</p>
    <pre><code class="python">
    from staticconf import schema

    validator = ...
    custom_type = schema.build_value_type(validator)


    class MySchema(object):
        __metaclass__ = schema.SchemaMeta

        something = custom_type(default=...)
    </code></pre>
  </section>
</section>

<section>
  <section>
    <h3>Reloading</h3>
    <p>Configuration can change</p>
    <ul class="spaced">
      <li>long running processes should be able to pick up configuration changes</li>
      <li>program structure shouldn't need to change</li>
      <li>reloading the entire file can be expensive</li>
    </ul>
  </section>

  <section>
    <p class="left">Testing for modified files</p>
    <pre><code class="python">
 # Only check for modifications once ever min_interval
 def should_check(self):
     return self.last_check + self.min_interval &lt;= time.time()

 # Get the most recent modified time
 def most_recent_changed(self):
     return max(os.path.getmtime(name)
                for name in self.filenames)

 # Get the inode and device id of files
 def get_inodes(self):
     def get_inode(stbuf):
         return stbuf.st_dev, stbuf.st_ino
     return [get_inode(os.stat(filename))
             for filename in self.filenames]
    </code></pre>
  </section>

  <section>
    <p class="left">ConfigurationWatcher</p>
    <pre><code class="python">
 class ConfigurationWatcher(object):
 
     def __init__(self,
                  config_loader,
                  filenames,
                  min_interval=0,
                  reloader=None):
         ...
 
     def reload_if_changed(self, force=False):
         if (force or self.should_check) \
                 and self.file_modified():
             return self.reload()
    </code></pre>
  </section>

  <section>
    <p class="left">Composing configuration loaders</p>
    <pre><code class="python">

  def load(filenames):
      for name in filenames:
          YamlConfiguration(name)

  watcher = ConfigurationWatcher(load, filenames)
  watcher.load_config()
  ...

  for work in work_items:
      watcher.reload_if_changed()
      ...
    </code></pre>
  </section>
</section>

<section>
  <section>
    <h3>Finally</h3>
    <ul class="spaced">
      <li>classes and types</li>
      <li>special attributes</li>
      <li>metaclasses</li>
      <li>decorators</li>
      <li>descriptors</li>
      <li>slots</li>
      <li>weakref</li>
    </ul>
  </section>

<!-- 
  <section>
    <h3>Also...</h3>
    <ul class="spaced">
      <li>unit tests</li>
      <li>acceptance tests</li>
      <li>composition, no inheritance</li>
      <li>sphinx documentation</li>
    </ul>
  </section>
-->

  <section>
      <h3>References</h3>
      <ul>
        <li><a href="https://github.com/dnephin/PyStaticConfiguration">
            github.com/dnephin/PyStaticConfiguration</a></li>
        <li><a href="https://pypi.python.org/pypi/PyStaticConfiguration">
            pypi.org/pypi/PyStaticConfiguration</a></li>
        <li><a href="http://pythonhosted.org/PyStaticConfiguration/">
            pythonhosted.org/PyStaticConfiguration</a></li>
      </ul>
  </section>
</section>

            </div>
        </div>

        <script src="reveal.js/js/reveal.min.js"></script>
        <script>

            // Full list of configuration options available here:
            // https://github.com/hakimel/reveal.js#configuration
            Reveal.initialize({
                controls:       false,
                progress:       true,
                history:        true,
                center:         true,
                rollingLinks:   false,
                transition:     'linear', // default/cube/page/concave/zoom/linear/fade/none
                theme:          'beige',

                dependencies: [
                    { src: 'reveal.js/lib/js/classList.js',
                      condition: function() { return !document.body.classList; } },
                    { src: 'reveal.js/plugin/markdown/marked.js',
                      condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
                    { src: 'reveal.js/plugin/markdown/markdown.js',
                      condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
                    { src: 'reveal.js/plugin/highlight/highlight.js', async: true,
                      callback: function() { hljs.initHighlightingOnLoad(); } },
                    { src: 'reveal.js/plugin/zoom-js/zoom.js', async: true,
                      condition: function() { return !!document.body.classList; } },
                    { src: 'reveal.js/plugin/notes/notes.js', async: true,
                      condition: function() { return !!document.body.classList; } }
                    /*
                    { src: 'reveal.js/plugin/search/search.js', async: true,
                      condition: function() { return !!document.body.classList; } }
                    { src: 'reveal.js/plugin/remotes/remotes.js', async: true,
                      condition: function() { return !!document.body.classList; } }
                    */
                ]
            });

        </script>
        <script src="http://localhost:8887/livereload.js"></script>

    </body>
</html>
